<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AYOUB BACCARAT ULTIMATE - Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');
:root{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#070606;--card:#0f0e10;--muted:#bfb7a6;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
:root[data-theme="light"]{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#f5f5f5;--card:#ffffff;--muted:#666666;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
*{box-sizing:border-box;margin:0;padding:0;}
body{font-family:Inter,sans-serif;margin:0;background:linear-gradient(180deg,var(--bg-dark),#0b0b0b);color:#fff;padding:18px;transition:background 0.3s, color 0.3s;min-height:100vh;}
:root[data-theme="light"] body{color:#333;}
.app{max-width:1200px;margin:0 auto;width:100%;}
.top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px;flex-wrap:wrap;}
.logo{font-weight:800;background:linear-gradient(90deg,var(--gold),#fff3b0);color:#000;padding:8px 12px;border-radius:12px;display:inline-block;font-size:1.2rem;}
.subtitle{font-size:14px;color:var(--muted);margin-top:4px;}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.card{background:linear-gradient(180deg,var(--card),#0b0b0b);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);border:1px solid rgba(212,175,55,0.08);margin-bottom:10px;}
:root[data-theme="light"] .card{background:linear-gradient(180deg,var(--card),#f0f0f0);box-shadow:0 8px 30px rgba(0,0,0,0.1);border:1px solid rgba(0,0,0,0.05);}
.layout{display:flex;gap:12px;flex-wrap:wrap;}
.left{width:360px;min-width:300px;display:flex;flex-direction:column;gap:10px;flex:1;}
.right{flex:2;display:flex;flex-direction:column;gap:12px;min-width:300px;}
.panel{padding:10px;}
.row{display:flex;gap:8px;align-items:center;margin-top:8px;}
input[type=number], select{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);padding:10px;border-radius:8px;color:#fff;font-weight:600;font-size:14px;width:100%;}
:root[data-theme="light"] input[type=number], :root[data-theme="light"] select{background:rgba(255,255,255,0.9);border:2px solid rgba(0,0,0,0.2);color:#333;}
.btn{padding:12px 16px;border-radius:8px;border:0;color:#fff;cursor:pointer;font-weight:600;font-size:16px;transition:all 0.3s;text-align:center;min-width:70px;}
.btn:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.3);}
.btn:active{transform:translateY(0);}
.btn.gold{background:linear-gradient(90deg,var(--gold),var(--gold-2));color:#000;font-weight:700;box-shadow:0 6px 20px rgba(212,175,55,0.3);}
.btn.player{background:linear-gradient(135deg, #3a86ff, #2667cc); color:white; border:2px solid #3a86ff;}
.btn.banker{background:linear-gradient(135deg, #ff006e, #cc0058); color:white; border:2px solid #ff006e;}
.btn.tie{background:linear-gradient(135deg, #38b000, #2c8a00); color:white; border:2px solid #38b000;}
:root[data-theme="light"] .btn.player{background:linear-gradient(135deg, #2d7ef7, #1a67d8); color:white;}
:root[data-theme="light"] .btn.banker{background:linear-gradient(135deg, #e03b3b, #c53232); color:white;}
:root[data-theme="light"] .btn.tie{background:linear-gradient(135deg, #28a745, #218838); color:white;}
:root[data-theme="light"] .btn{background:rgba(0,0,0,0.1);color:#333; border:1px solid rgba(0,0,0,0.1)}
.small{font-size:13px;color:var(--muted);}
.muted{color:var(--muted);font-size:12px;}
.pattern-list{list-style:none;padding:6px;margin:6px 0 0 0;max-height:200px;overflow:auto;}
.pattern-list li{padding:8px;border-radius:8px;margin-bottom:6px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);display:flex;justify-content:space-between;align-items:center;}
:root[data-theme="light"] .pattern-list li{background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent);}
.section-title{font-weight:700;margin-bottom:6px;color:var(--gold);font-size:1.1rem;}
.stat-table{width:100%;border-collapse:collapse;font-size:13px;}
.stat-table th,.stat-table td{border:1px solid rgba(255,255,255,0.05);padding:6px;text-align:center;}
:root[data-theme="light"] .stat-table th, :root[data-theme="light"] .stat-table td{border:1px solid rgba(0,0,0,0.05);}
.stat-table th{background:rgba(212,175,55,0.1);font-weight:600;}
.player{color:#3a86ff;font-weight:700;}
.banker{color:#ff006e;font-weight:700;}
.tie{color:#38b000;font-weight:700;}
.pred-head{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px;}
.final{font-size:22px;font-weight:800;text-align:center;padding:12px;background:linear-gradient(90deg,rgba(212,175,55,0.06),transparent);border-radius:10px;margin:10px 0;}
:root[data-theme="light"] .final{background:linear-gradient(90deg,rgba(212,175,55,0.1),transparent);}
.foot{display:flex;justify-content:space-between;align-items:center;margin-top:14px;flex-wrap:wrap;gap:10px;}
.credits{opacity:0.85;font-size:12px;}
canvas{border-radius:10px;background:#0f0e10;width:100% !important;height:auto !important;max-height:450px;}
:root[data-theme="light"] canvas{background:#f0f0f0;}
.color-legend{display:flex;gap:15px;justify-content:center;margin-bottom:10px;font-size:14px;flex-wrap:wrap;}
.color-legend span{padding:4px 8px;border-radius:6px; font-weight:600;}
.prediction-cards{display:flex;gap:10px;justify-content:center;margin:10px 0;flex-wrap:wrap;}
.pred-card{padding:10px;border-radius:8px;text-align:center;min-width:80px; font-weight:600;flex:1;}
.pred-card.active{transform:scale(1.05);border:2px solid var(--gold); box-shadow:0 4px 15px rgba(212,175,55,0.4);}
.win-effect{animation:winPulse 0.5s ease-in-out;}
.loss-effect{animation:lossShake 0.5s ease-in-out;}
@keyframes winPulse{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}
@keyframes lossShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}
.analysis-result{margin-top:10px;padding:10px;background:rgba(255,255,255,0.03);border-radius:8px;text-align:center;}
:root[data-theme="light"] .analysis-result{background:rgba(0,0,0,0.03);}
.theme-toggle{background:transparent;border:none;font-size:24px;cursor:pointer;padding:5px;border-radius:50%;transition:background 0.3s;width:40px;height:40px;display:flex;align-items:center;justify-content:center;}
.theme-toggle:hover{background:rgba(255,255,255,0.1);}
:root[data-theme="light"] .theme-toggle:hover{background:rgba(0,0,0,0.05);}
.input-group {display: flex; gap: 8px; align-items: center;}
.input-group input {flex: 1;}
.input-label {font-weight: 600; margin-bottom: 6px; display: block;}
.pred-card.player {background: linear-gradient(135deg, #3a86ff, #2667cc); color: white;}
.pred-card.banker {background: linear-gradient(135deg, #ff006e, #cc0058); color: white;}
.pred-card.tie {background: linear-gradient(135deg, #38b000, #2c8a00); color: white;}
.accuracy-panel {margin-top: 12px;}
.accuracy-stats {display: flex; justify-content: space-between; margin-bottom: 8px; flex-wrap: wrap; gap: 10px;}
.accuracy-stats > div {flex: 1; min-width: 120px;}
.accuracy-value {font-weight: 700; font-size: 18px;}
.accuracy-label {font-size: 12px; color: var(--muted);}
.accuracy-chart-container {position: relative; height: 80px; margin-top: 8px; width: 100%;}
.accuracy-line {stroke: var(--gold); stroke-width: 2; fill: none;}
.accuracy-point {fill: var(--gold); r: 3; transition: r 0.2s;}
.accuracy-point:hover {r: 5;}
.accuracy-grid {stroke: rgba(255,255,255,0.1); stroke-width: 1;}
:root[data-theme="light"] .accuracy-grid {stroke: rgba(0,0,0,0.1);}
.accuracy-tooltip {position: absolute; background: rgba(0,0,0,0.9); color: white; padding: 5px 8px; border-radius: 4px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 100;}
.advanced-controls {background: rgba(212,175,55,0.05); border-radius: 8px; padding: 10px; margin-top: 8px;}
.control-group {display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap;}
.control-group:last-child {margin-bottom: 0;}
.slider-container {flex: 1; margin-left: 10px; min-width: 150px;}
.slider {width: 100%;}
.model-badge {display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: 600; margin-left: 5px;}
.badge-basic {background: #3a86ff; color: white;}
.badge-advanced {background: #ff006e; color: white;}
.badge-pattern {background: #38b000; color: white;}
.badge-ml {background: #9d4edd; color: white;}
.pattern-info {font-size: 11px; color: var(--muted); margin-top: 4px; line-height: 1.4;}
.confidence-meter {height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 4px; overflow: hidden;}
.confidence-fill {height: 100%; background: linear-gradient(90deg, #38b000, #ff006e); border-radius: 3px; transition: width 0.3s;}
.high-confidence {background: linear-gradient(90deg, #38b000, #d4af37);}
.medium-confidence {background: linear-gradient(90deg, #d4af37, #ff006e);}
.switch {position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0;}
.switch input {opacity: 0; width: 0; height: 0;}
.switch .slider {position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px;}
.switch .slider:before {position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%;}
.switch input:checked + .slider {background: linear-gradient(90deg, #9d4edd, #7b2cbf);}
.switch input:checked + .slider:before {transform: translateX(26px);}
.ml-training-indicator {display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px;}
.ml-training {background: #38b000; animation: pulse 1.5s infinite;}
.ml-not-trained {background: #ff006e;}
@keyframes pulse {0% {opacity: 1;} 50% {opacity: 0.5;} 100% {opacity: 1;}}
.ml-info-panel {background: rgba(157, 78, 221, 0.05); border-left: 3px solid #9d4edd;}
.data-controls {display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;}
.data-controls .btn {padding: 6px 10px; font-size: 12px; flex: 1; min-width: 100px;}
@media (max-width: 768px) {
    .layout {flex-direction: column;}
    .left, .right {width: 100%;}
    .top {flex-direction: column; align-items: flex-start;}
    .controls {width: 100%; justify-content: space-between;}
    .accuracy-stats > div {min-width: 100px;}
    .prediction-cards {flex-direction: column;}
    .pred-card {width: 100%;}
    .color-legend {justify-content: flex-start;}
    .row {flex-wrap: wrap;}
    .btn {flex: 1; min-width: 60px;}
}
@media (max-width: 480px) {
    body {padding: 10px;}
    .card {padding: 8px;}
    .btn {padding: 10px 12px; font-size: 14px;}
    .accuracy-stats {flex-direction: column;}
    .accuracy-stats > div {min-width: 100%;}
}
</style>
</head>
<body>
<div class="app">
<header class="top card">
  <div class="brand">
    <div class="logo">AYOUB BACCARAT ULTIMATE <span class="model-badge badge-ml">v3.0</span></div>
    <div class="subtitle">Ù†Ø¸Ø§Ù… ØªÙ†Ø¨Ø¤ Ø°ÙƒÙŠ - Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ù…Ø­Ø³Ù†Ø© ÙˆÙ…ØµØ­Ø­Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ ğŸ§ ğŸ’¾</div>
  </div>
  <div class="controls">
    <button id="themeToggle" class="theme-toggle" title="ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹">ğŸŒš</button>
    <button id="btnReset" class="btn gold">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
  </div>
</header>

<main class="layout">
<aside class="left">
  <div class="panel card">
    <label class="input-label">Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ (5 - 15)</label>
    <div class="input-group">
      <input id="windowSize" type="number" min="5" max="15" value="8">
      <button id="applyWindow" class="btn gold">ØªØ·Ø¨ÙŠÙ‚</button>
    </div>
    <div class="muted small">ÙŠØ­Ù„Ù„ Ø¢Ø®Ø± 5-15 Ø¬ÙˆÙ„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</div>
  </div>

  <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… -->
  <div class="panel card">
    <div class="section-title">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</div>
    <div class="advanced-controls">
      <div class="control-group">
        <label for="analysisMode">Ù†Ù…Ø· Ø§Ù„ØªØ­Ù„ÙŠÙ„:</label>
        <select id="analysisMode">
          <option value="basic" selected>Ø£Ø³Ø§Ø³ÙŠ <span class="model-badge badge-basic">+5%</span></option>
          <option value="advanced">Ù…ØªÙ‚Ø¯Ù… <span class="model-badge badge-advanced">+15%</span></option>
          <option value="pattern">ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· <span class="model-badge badge-pattern">+25%</span></option>
          <option value="ml">ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© <span class="model-badge badge-ml">+35%</span></option>
        </select>
      </div>
      <div class="control-group">
        <label for="timeWeighting">Ø§Ù„Ù…Ø±Ø¬Ø­Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©:</label>
        <select id="timeWeighting">
          <option value="none">Ø¨Ø¯ÙˆÙ†</option>
          <option value="linear" selected>Ø®Ø·ÙŠ</option>
          <option value="exponential">Ø£Ø³Ù‘ÙŠ</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Ù‚Ø³Ù… ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© -->
  <div class="panel card ml-info-panel">
    <div class="section-title">âš™ï¸ ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©</div>
    <div class="row">
      <label class="switch">
        <input type="checkbox" id="mlToggle" checked>
        <span class="slider"></span>
      </label>
      <span>ØªÙØ¹ÙŠÙ„ ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©</span>
    </div>
    <div class="row">
      <select id="mlModelSelect" style="flex:1; margin-top: 5px;">
        <option value="knn">K-Ø§Ù„Ø¬ÙŠØ±Ø§Ù† Ø§Ù„Ø£Ù‚Ø±Ø¨</option>
        <option value="logistic">Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± Ø§Ù„Ù„ÙˆØ¬Ø³ØªÙŠ</option>
        <option value="ensemble" selected>Ø§Ù„Ù…Ø¬Ù…Ø¹ (Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬)</option>
      </select>
    </div>
    <div class="row">
      <div id="mlStatus" class="muted small">
        <span class="ml-training-indicator ml-training"></span> 
        Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ÙŠØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...
      </div>
    </div>
    <div class="pattern-info">
      <span id="mlTrainingCount">0</span> Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨ â€¢ 
      <span id="mlAccuracy">0%</span> Ø¯Ù‚Ø© â€¢ 
      <span id="mlWeight">30%</span> ØªØ£Ø«ÙŠØ±
    </div>
  </div>

  <!-- Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ -->
  <div class="panel card">
    <div class="section-title">Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</div>
    <div class="row">
      <button class="btn player" id="btnP">Ù„Ø§Ø¹Ø¨ ğŸ”µ</button>
      <button class="btn banker" id="btnB">Ù…ØµØ±ÙÙŠ ğŸ”´</button>
      <button class="btn tie" id="btnT">ØªØ¹Ø§Ø¯Ù„ ğŸŸ¢</button>
    </div>
    <div class="row">
      <button class="btn" id="btnUndo" style="flex:1; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2)">ØªØ±Ø§Ø¬Ø¹</button>
    </div>
    <div class="muted small" style="margin-top: 8px; text-align: center;">
      Ø£Ø¯Ø®Ù„ Ù†ØªÙŠØ¬Ø© ÙƒÙ„ Ø¬ÙˆÙ„Ø© Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
    </div>
  </div>

  <!-- Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª -->
  <div class="panel card stats">
    <div class="section-title">Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</div>
    <table class="stat-table">
      <thead>
        <tr><th>Ø§Ù„Ø¬Ù‡Ø©</th><th>Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹</th><th>ÙÙˆØ²</th><th>Ø®Ø³Ø§Ø±Ø©</th><th>Ù†Ø³Ø¨Ø© %</th><th>Ø¯Ù‚Ø©</th><th>ML Ø¯Ù‚Ø©</th></tr>
      </thead>
      <tbody>
        <tr><td class="player">Ù„Ø§Ø¹Ø¨</td><td id="pTotal">0</td><td id="pWin">0</td><td id="pLoss">0</td><td id="pPct">0%</td><td id="pAccuracy">0%</td><td id="pMLAccuracy">0%</td></tr>
        <tr><td class="banker">Ù…ØµØ±ÙÙŠ</td><td id="bTotal">0</td><td id="bWin">0</td><td id="bLoss">0</td><td id="bPct">0%</td><td id="bAccuracy">0%</td><td id="bMLAccuracy">0%</td></tr>
        <tr><td class="tie">ØªØ¹Ø§Ø¯Ù„</td><td id="tTotal">0</td><td id="tWin">0</td><td id="tLoss">0</td><td id="tPct">0%</td><td id="tAccuracy">0%</td><td id="tMLAccuracy">0%</td></tr>
      </tbody>
    </table>
    <div class="pattern-info" id="patternInfo">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…ÙƒØªØ´ÙØ© Ø¨Ø¹Ø¯</div>
  </div>

  <!-- Ù…Ø¤Ø´Ø± Ø§Ù„Ø«Ù‚Ø© (Ø¨Ø¯ÙˆÙ† Ù†Ø³Ø¨Ø© Ø­Ø³Ø§Ø³ÙŠØ©) -->
  <div class="panel card">
    <div class="section-title">Ù…Ø¤Ø´Ø± Ø§Ù„Ø«Ù‚Ø©</div>
    <div class="muted small" id="confidenceLabel">Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©</div>
    <div class="confidence-meter">
      <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
    </div>
    <div class="pattern-info" id="modelInfo">Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: Ø£Ø³Ø§Ø³ÙŠ</div>
  </div>
</aside>

<section class="right">
  <div class="card prediction">
    <div class="pred-head">
      <div class="pred-title">ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© <span id="predModel" class="model-badge badge-basic">Ø£Ø³Ø§Ø³ÙŠ</span></div>
      <div class="pred-sub">Ù†Ø¸Ø§Ù… ØªÙ†Ø¨Ø¤ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ù…Ø¹ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ØªØ¹Ù„Ù… Ø¢Ù„Ø©</div>
    </div>

    <div class="color-legend">
      <span style="background:linear-gradient(135deg, #3a86ff, #2667cc);">ğŸ”µ Ù„Ø§Ø¹Ø¨</span>
      <span style="background:linear-gradient(135deg, #ff006e, #cc0058);">ğŸ”´ Ù…ØµØ±ÙÙŠ</span>
      <span style="background:linear-gradient(135deg, #38b000, #2c8a00);">ğŸŸ¢ ØªØ¹Ø§Ø¯Ù„</span>
    </div>
    
    <canvas id="bigRoad" width="800" height="450"></canvas>

    <div class="prediction-cards">
      <div class="pred-card player" id="predP">
        <div>Ù„Ø§Ø¹Ø¨</div>
        <div id="predPctP">0%</div>
        <div class="muted small" id="predTrendP">â†’</div>
      </div>
      <div class="pred-card banker" id="predB">
        <div>Ù…ØµØ±ÙÙŠ</div>
        <div id="predPctB">0%</div>
        <div class="muted small" id="predTrendB">â†’</div>
      </div>
      <div class="pred-card tie" id="predT">
        <div>ØªØ¹Ø§Ø¯Ù„</div>
        <div id="predPctT">0%</div>
        <div class="muted small" id="predTrendT">â†’</div>
      </div>
    </div>

    <div class="analysis-result">
      <div class="muted">Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ:</div>
      <div class="final" id="finalCard">â€”</div>
      <div class="muted small" id="predictionReason">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„</div>
      <div class="muted small" id="mlContribution" style="margin-top: 5px; color: #9d4edd;"></div>
    </div>
  </div>

  <!-- Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª -->
  <div class="panel card accuracy-panel">
    <div class="section-title">Ù…Ù†Ø­Ù†Ù‰ Ø¯Ù‚Ø© Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</div>
    <div class="accuracy-stats">
      <div>
        <div class="accuracy-label">Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©</div>
        <div class="accuracy-value" id="currentAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">Ø£ÙØ¶Ù„ Ø¯Ù‚Ø©</div>
        <div class="accuracy-value" id="bestAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ù‚Ø©</div>
        <div class="accuracy-value" id="averageAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">Ø¯Ù‚Ø© ML</div>
        <div class="accuracy-value" id="mlOverallAccuracy">0%</div>
      </div>
    </div>
    <div class="accuracy-chart-container">
      <svg id="accuracyChart" width="100%" height="100%"></svg>
      <div id="accuracyTooltip" class="accuracy-tooltip"></div>
    </div>
    <div class="muted small">ØªØªØ¨Ø¹ Ø¯Ù‚Ø© ØªÙˆÙ‚Ø¹Ø§ØªÙƒ Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©</div>
  </div>
</section>
</main>

<footer class="foot card">
  <div style="flex: 1;">
    <div>ØªØµÙ…ÙŠÙ…: Ayoub â€¢ Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø§Ù„Ù…ØµØ­Ø­ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„</div>
    <div class="credits small">Ù†Ø¸Ø§Ù… Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ â€¢ ØªØ¹Ù„Ù… Ø¢Ù„Ø© Ù…Ø­Ø³Ù† â€¢ Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ â€¢ Ù…Ø¤Ø´Ø±Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</div>
  </div>
  <div class="data-controls">
    <button id="btnExport" class="btn" style="background: rgba(59, 130, 246, 0.2); border: 1px solid #3a86ff;">ğŸ“¥ ØªØµØ¯ÙŠØ±</button>
    <button id="btnImport" class="btn" style="background: rgba(16, 185, 129, 0.2); border: 1px solid #10b981;">ğŸ“¤ Ø§Ø³ØªÙŠØ±Ø§Ø¯</button>
    <button id="btnClearData" class="btn" style="background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444;">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
  </div>
  <div class="muted small" style="text-align: center; width: 100%; margin-top: 10px;">
    <span id="autoSaveStatus">ğŸ’¾ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„</span> â€¢ 
    <span id="dataStats">0 Ø¬ÙˆÙ„Ø© â€¢ 0 Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨</span>
  </div>
</footer>
</div>

<script>
(function() {
// ========== Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© ==========

class SimpleKNN {
  constructor(k = 3) {
    this.k = k;
    this.trainingData = [];
    this.predictions = { correct: 0, total: 0 };
    this.trainingQueue = [];
    this.isTraining = false;
  }

  train(features, labels) {
    if (!features || !labels || features.length === 0) return;
    
    features.forEach((f, i) => {
      if (f && labels[i]) {
        this.trainingData.push({
          features: f,
          label: labels[i]
        });
      }
    });
    
    if (this.trainingData.length > 200) {
      this.trainingData = this.trainingData.slice(-200);
    }
  }

  predict(newFeatures) {
    if (!newFeatures || this.trainingData.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }

    try {
      const distances = this.trainingData.map((dataPoint) => ({
        distance: this.euclideanDistance(newFeatures, dataPoint.features),
        label: dataPoint.label
      }));

      distances.sort((a, b) => a.distance - b.distance);
      const nearestNeighbors = distances.slice(0, this.k);
      
      const votes = { P: 0, B: 0, T: 0 };
      nearestNeighbors.forEach(n => {
        if (n.label in votes) {
          votes[n.label] += 1 / (n.distance + 0.001);
        }
      });

      const total = votes.P + votes.B + votes.T;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: Number(((votes.P / total) * 100).toFixed(1)),
        B: Number(((votes.B / total) * 100).toFixed(1)),
        T: Number(((votes.T / total) * 100).toFixed(1))
      };
    } catch (e) {
      console.error('KNN prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  euclideanDistance(a, b) {
    if (!a || !b || a.length !== b.length) return 1000;
    
    let sum = 0;
    for (let i = 0; i < a.length; i++) {
      sum += Math.pow((a[i] || 0) - (b[i] || 0), 2);
    }
    return Math.sqrt(sum);
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      Number(((this.predictions.correct / this.predictions.total) * 100).toFixed(1)) : 0;
  }
}

class SimpleLogisticRegression {
  constructor() {
    this.weights = { P: 0.1, B: 0.1, T: 0.1 };
    this.bias = 0;
    this.learningRate = 0.01;
    this.predictions = { correct: 0, total: 0 };
  }

  sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
  }

  trainOne(features, label) {
    if (!features || !label || features.length === 0) return;
    
    try {
      const labelNum = { P: 0, B: 1, T: 2 }[label];
      if (labelNum === undefined) return;
      
      const score = features[0] * this.weights.P + features[1] * this.weights.B + features[2] * this.weights.T + this.bias;
      const prediction = this.sigmoid(score);
      const error = (labelNum / 2) - prediction;
      
      this.weights.P += this.learningRate * error * features[0];
      this.weights.B += this.learningRate * error * features[1];
      this.weights.T += this.learningRate * error * features[2];
      this.bias += this.learningRate * error;
    } catch (e) {
      console.error('Logistic regression training error:', e);
    }
  }

  predict(features) {
    if (!features || features.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
    
    try {
      const pScore = this.sigmoid(features[0] * this.weights.P + this.bias);
      const bScore = this.sigmoid(features[1] * this.weights.B + this.bias);
      const tScore = this.sigmoid(features[2] * this.weights.T + this.bias);
      
      const total = pScore + bScore + tScore;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: Number(((pScore / total) * 100).toFixed(1)),
        B: Number(((bScore / total) * 100).toFixed(1)),
        T: Number(((tScore / total) * 100).toFixed(1))
      };
    } catch (e) {
      console.error('Logistic regression prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      Number(((this.predictions.correct / this.predictions.total) * 100).toFixed(1)) : 0;
  }
}

class EnsembleModel {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression()
    };
    this.weights = { knn: 0.5, logistic: 0.5 };
    this.predictions = { correct: 0, total: 0 };
  }

  train(features, label) {
    if (!features || !label) return;
    
    try {
      this.models.knn.train([features], [label]);
      this.models.logistic.trainOne(features, label);
      
      const knnAcc = this.models.knn.getAccuracy();
      const logisticAcc = this.models.logistic.getAccuracy();
      
      const totalAcc = knnAcc + logisticAcc + 0.001;
      this.weights.knn = knnAcc / totalAcc;
      this.weights.logistic = logisticAcc / totalAcc;
    } catch (e) {
      console.error('Ensemble training error:', e);
    }
  }

  predict(features) {
    if (!features) return { P: 33.3, B: 33.3, T: 33.3 };
    
    try {
      const knnPred = this.models.knn.predict(features);
      const logisticPred = this.models.logistic.predict(features);
      
      return {
        P: Number((knnPred.P * this.weights.knn + logisticPred.P * this.weights.logistic).toFixed(1)),
        B: Number((knnPred.B * this.weights.knn + logisticPred.B * this.weights.logistic).toFixed(1)),
        T: Number((knnPred.T * this.weights.knn + logisticPred.T * this.weights.logistic).toFixed(1))
      };
    } catch (e) {
      console.error('Ensemble prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
    
    this.models.knn.updateAccuracy(prediction, actual);
    this.models.logistic.updateAccuracy(prediction, actual);
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      Number(((this.predictions.correct / this.predictions.total) * 100).toFixed(1)) : 0;
  }
}

class BaccaratMachineLearning {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.activeModel = 'ensemble';
    this.featureHistory = [];
    this.mlPredictions = [];
    this.isEnabled = true;
    this.trainingTimer = null;
  }

  extractFeatures(rounds, windowSize) {
    if (!rounds || rounds.length < windowSize) return null;
    
    try {
      const recent = rounds.slice(-windowSize);
      const pRatio = recent.filter(r => r === 'P').length / windowSize;
      const bRatio = recent.filter(r => r === 'B').length / windowSize;
      const tRatio = recent.filter(r => r === 'T').length / windowSize;
      
      let pStreak = 0, bStreak = 0;
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'P') pStreak++; else break;
      }
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'B') bStreak++; else break;
      }
      
      const volatility = this.calculateVolatility(recent);
      const patternType = this.getPatternType(recent);
      
      return [
        Number(pRatio.toFixed(2)),
        Number(bRatio.toFixed(2)),
        Number(tRatio.toFixed(2)),
        Number((pStreak / windowSize).toFixed(2)),
        Number((bStreak / windowSize).toFixed(2)),
        recent[recent.length - 1] === recent[recent.length - 2] ? 1 : 0,
        Number(volatility.toFixed(2)),
        patternType
      ];
    } catch (e) {
      console.error('Feature extraction error:', e);
      return null;
    }
  }

  calculateVolatility(rounds) {
    if (rounds.length < 2) return 0;
    let changes = 0;
    for (let i = 1; i < rounds.length; i++) {
      if (rounds[i] !== rounds[i-1]) changes++;
    }
    return changes / (rounds.length - 1);
  }

  getPatternType(rounds) {
    if (rounds.length < 3) return 0;
    const lastThree = rounds.slice(-3);
    if (lastThree[0] === lastThree[1] && lastThree[1] === lastThree[2]) return 1;
    if (lastThree[0] !== lastThree[1] && lastThree[1] !== lastThree[2]) return 2;
    return 0;
  }

  updateModel(rounds, windowSize, actualResult) {
    if (!this.isEnabled || !rounds || !actualResult) return;
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return;
    
    try {
      this.featureHistory.push({ features, label: actualResult, timestamp: Date.now() });
      
      if (this.featureHistory.length > 200) {
        this.featureHistory = this.featureHistory.slice(-200);
      }
      
      if (this.featureHistory.length > 5) {
        if (this.trainingTimer) clearTimeout(this.trainingTimer);
        this.trainingTimer = setTimeout(() => {
          this.batchTrain();
        }, 500);
      }
    } catch (e) {
      console.error('ML update error:', e);
    }
  }

  batchTrain() {
    if (this.featureHistory.length < 5) return;
    
    const trainingBatch = this.featureHistory.slice(-30);
    trainingBatch.forEach(({ features, label }) => {
      if (features && label) {
        this.models.knn.train([features], [label]);
        this.models.logistic.trainOne(features, label);
        this.models.ensemble.train(features, label);
      }
    });
  }

  predict(rounds, windowSize) {
    if (!this.isEnabled || !rounds || rounds.length < windowSize) {
      return null;
    }
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return null;
    
    try {
      let prediction;
      switch(this.activeModel) {
        case 'knn':
          prediction = this.models.knn.predict(features);
          break;
        case 'logistic':
          prediction = this.models.logistic.predict(features);
          break;
        case 'ensemble':
        default:
          prediction = this.models.ensemble.predict(features);
          break;
      }
      
      if (prediction) {
        this.mlPredictions.push({
          features,
          prediction: this.getPredictedClass(prediction),
          timestamp: Date.now()
        });
        
        if (this.mlPredictions.length > 50) {
          this.mlPredictions = this.mlPredictions.slice(-50);
        }
      }
      
      return prediction;
    } catch (e) {
      console.error('ML prediction error:', e);
      return null;
    }
  }

  getPredictedClass(prediction) {
    if (!prediction) return null;
    const entries = Object.entries(prediction);
    if (entries.length === 0) return null;
    
    entries.sort((a, b) => b[1] - a[1]);
    return entries[0][0];
  }

  getModelAccuracy(modelName) {
    const model = this.models[modelName];
    return model && model.getAccuracy ? model.getAccuracy() : 0;
  }

  getTrainingDataCount() {
    return this.featureHistory.length;
  }

  getMLWeight() {
    const minWeight = 0.1;
    const maxWeight = 0.6;
    const dataPoints = this.getTrainingDataCount();
    const weight = minWeight + (maxWeight - minWeight) * Math.min(dataPoints / 100, 1);
    return Number(weight.toFixed(2));
  }

  enable() {
    this.isEnabled = true;
  }

  disable() {
    this.isEnabled = false;
  }

  setActiveModel(modelName) {
    if (this.models[modelName]) {
      this.activeModel = modelName;
    }
  }

  reset() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.featureHistory = [];
    this.mlPredictions = [];
    if (this.trainingTimer) clearTimeout(this.trainingTimer);
  }

  getStats() {
    return {
      trainingCount: this.featureHistory.length,
      accuracy: this.getModelAccuracy(this.activeModel),
      weight: this.getMLWeight(),
      isEnabled: this.isEnabled,
      activeModel: this.activeModel
    };
  }
}

// ========== Ù†Ø¸Ø§Ù… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù† ==========

class DataManager {
  constructor() {
    this.storageKey = 'baccaratUltimate_v3';
    this.autoSaveInterval = null;
    this.lastSaveTime = null;
    this.isSaving = false;
  }

  saveAllData() {
    if (this.isSaving) return false;
    
    this.isSaving = true;
    try {
      const saveData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize,
          analysisMode: state.analysisMode,
          timeWeighting: state.timeWeighting,
          useML: state.useML,
          mlModel: state.mlModel,
          modelPerformance: state.modelPerformance,
          predictionsHistory: state.predictionsHistory
        },
        mlData: {
          featureHistory: state.ml.featureHistory,
          mlPredictions: state.ml.mlPredictions,
          activeModel: state.ml.activeModel,
          isEnabled: state.ml.isEnabled
        },
        meta: {
          version: '3.0',
          lastSave: new Date().toISOString(),
          totalRounds: state.rounds.length
        }
      };

      localStorage.setItem(this.storageKey, JSON.stringify(saveData));
      this.lastSaveTime = new Date();
      this.updateSaveStatus(true);
      return true;
    } catch (e) {
      console.error('Error saving data:', e);
      this.updateSaveStatus(false, 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸');
      return false;
    } finally {
      this.isSaving = false;
    }
  }

  loadAllData() {
    try {
      const saved = localStorage.getItem(this.storageKey);
      if (!saved) {
        this.updateSaveStatus(true, 'Ø¨Ø¯ÙˆÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø³Ø§Ø¨Ù‚Ø©');
        return false;
      }

      const data = JSON.parse(saved);
      
      if (data.state) {
        state.rounds = Array.isArray(data.state.rounds) ? data.state.rounds : [];
        state.count = data.state.count || { P: 0, B: 0, T: 0 };
        state.win = data.state.win || { P: 0, B: 0, T: 0 };
        state.loss = data.state.loss || { P: 0, B: 0, T: 0 };
        state.windowSize = data.state.windowSize || 8;
        state.analysisMode = data.state.analysisMode || 'basic';
        state.timeWeighting = data.state.timeWeighting || 'linear';
        state.useML = data.state.useML !== false;
        state.mlModel = data.state.mlModel || 'ensemble';
        state.modelPerformance = data.state.modelPerformance || { basic: 0, advanced: 0, pattern: 0, ml: 0 };
        state.predictionsHistory = Array.isArray(data.state.predictionsHistory) ? data.state.predictionsHistory : [];
      }

      if (data.mlData) {
        state.ml.featureHistory = Array.isArray(data.mlData.featureHistory) ? data.mlData.featureHistory : [];
        state.ml.mlPredictions = Array.isArray(data.mlData.mlPredictions) ? data.mlData.mlPredictions : [];
        state.ml.activeModel = data.mlData.activeModel || 'ensemble';
        state.ml.isEnabled = data.mlData.isEnabled !== false;
        
        setTimeout(() => {
          if (state.ml.featureHistory.length > 5) {
            state.ml.batchTrain();
          }
        }, 1000);
      }

      this.lastSaveTime = new Date();
      this.updateSaveStatus(true, 'ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
      return true;
    } catch (e) {
      console.error('Error loading data:', e);
      this.updateSaveStatus(false, 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„');
      return false;
    }
  }

  exportData() {
    try {
      const exportData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize
        },
        ml: {
          featureHistory: state.ml.featureHistory,
          trainingCount: state.ml.getTrainingDataCount()
        },
        meta: {
          exportDate: new Date().toISOString(),
          version: 'AYOUB_BACCARAT_ULTIMATE_v3.0',
          totalRounds: state.rounds.length
        }
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `baccarat_data_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
      
      showToast(`âœ… ØªÙ… ØªØµØ¯ÙŠØ± ${state.rounds.length} Ø¬ÙˆÙ„Ø© Ø¨Ù†Ø¬Ø§Ø­`);
    } catch (e) {
      showToast('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'error');
    }
  }

  importData(file) {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const importedData = JSON.parse(e.target.result);
        
        if (!confirm(`Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${importedData.state?.rounds?.length || 0} Ø¬ÙˆÙ„Ø©ØŸ\nØ³ÙŠØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©.`)) {
          return;
        }

        resetAll();
        
        if (importedData.state) {
          state.rounds = Array.isArray(importedData.state.rounds) ? importedData.state.rounds : [];
          state.count = importedData.state.count || { P: 0, B: 0, T: 0 };
          state.win = importedData.state.win || { P: 0, B: 0, T: 0 };
          state.loss = importedData.state.loss || { P: 0, B: 0, T: 0 };
          state.windowSize = importedData.state.windowSize || 8;
          
          state.count = { P: 0, B: 0, T: 0 };
          state.rounds.forEach(round => {
            if (round in state.count) state.count[round]++;
          });
        }

        if (importedData.ml && Array.isArray(importedData.ml.featureHistory)) {
          state.ml.featureHistory = importedData.ml.featureHistory;
          
          setTimeout(() => {
            if (state.ml.featureHistory.length > 5) {
              state.ml.batchTrain();
            }
          }, 500);
        }

        updateAll();
        updateMLStatus();
        this.saveAllData();
        
        showToast(`âœ… ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${state.rounds.length} Ø¬ÙˆÙ„Ø© Ø¨Ù†Ø¬Ø§Ø­`);
      } catch (error) {
        showToast('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ù„Ù', 'error');
      }
    };
    
    reader.onerror = () => {
      showToast('âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù', 'error');
    };
    
    reader.readAsText(file);
  }

  clearAllData() {
    if (confirm('âš ï¸ Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ\nÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.')) {
      localStorage.removeItem(this.storageKey);
      resetAll();
      showToast('âœ… ØªÙ… Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
    }
  }

  startAutoSave(intervalSeconds = 30) {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }
    
    this.autoSaveInterval = setInterval(() => {
      if (state.rounds.length > 0 && !this.isSaving) {
        this.saveAllData();
      }
    }, intervalSeconds * 1000);
    
    window.addEventListener('beforeunload', () => {
      if (!this.isSaving) {
        this.saveAllData();
      }
    });
  }

  updateSaveStatus(success, message = '') {
    const statusEl = document.getElementById('autoSaveStatus');
    if (statusEl) {
      if (success) {
        const timeStr = this.lastSaveTime ? 
          `ğŸ’¾ Ø¢Ø®Ø± Ø­ÙØ¸: ${this.lastSaveTime.toLocaleTimeString('ar-EG', {hour: '2-digit', minute:'2-digit'})}` : 
          'ğŸ’¾ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„';
        statusEl.textContent = message || timeStr;
        statusEl.style.color = '#38b000';
      } else {
        statusEl.textContent = message || 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸';
        statusEl.style.color = '#ff006e';
      }
    }
  }

  updateDataStats() {
    const statsEl = document.getElementById('dataStats');
    if (statsEl) {
      statsEl.textContent = `${state.rounds.length} Ø¬ÙˆÙ„Ø© â€¢ ${state.ml.featureHistory.length} Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨`;
    }
  }
}

// ========== Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ·Ø¨ÙŠÙ‚ ==========
const state = {
  rounds: [],
  windowSize: 8,
  count: { P: 0, B: 0, T: 0 },
  win: { P: 0, B: 0, T: 0 },
  loss: { P: 0, B: 0, T: 0 },
  predictionsHistory: [],
  analysisMode: 'basic',
  timeWeighting: 'linear',
  modelPerformance: { basic: 0, advanced: 0, pattern: 0, ml: 0 },
  previousPredictions: { P: 0, B: 0, T: 0 },
  ml: new BaccaratMachineLearning(),
  useML: true,
  mlModel: 'ensemble',
  lastPrediction: null
};

const dataManager = new DataManager();

// ========== Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ==========
const el = id => document.getElementById(id);

// ========== Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ==========

function init() {
  console.log('Initializing Baccarat Ultimate...');
  
  dataManager.loadAllData();
  
  el('windowSize').value = state.windowSize;
  
  el('applyWindow').onclick = () => {
    const v = parseInt(el('windowSize').value);
    if (v >= 5 && v <= 15) {
      state.windowSize = v;
      updateAll();
      showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¥Ù„Ù‰ ${v} Ø¬ÙˆÙ„Ø§Øª`);
    } else {
      showToast('Ø§Ù„Ù†Ø§ÙØ°Ø© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø¨ÙŠÙ† 5 Ùˆ 15', 'error');
    }
  };

  el('analysisMode').value = state.analysisMode;
  el('analysisMode').onchange = (e) => {
    state.analysisMode = e.target.value;
    updateAll();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ù…Ø· Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¥Ù„Ù‰ ${getModeName(state.analysisMode)}`);
  };

  el('timeWeighting').value = state.timeWeighting;
  el('timeWeighting').onchange = (e) => {
    state.timeWeighting = e.target.value;
    updateAll();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø±Ø¬Ø­Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¥Ù„Ù‰ ${getWeightingName(state.timeWeighting)}`);
  };

  el('mlToggle').checked = state.useML;
  el('mlToggle').onchange = (e) => {
    state.useML = e.target.checked;
    state.ml.isEnabled = state.useML;
    updateMLStatus();
    updateAll();
    showToast(`ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© ${state.useML ? 'Ù…ÙØ¹Ù„' : 'Ù…Ø¹Ø·Ù„'}`);
  };

  el('mlModelSelect').value = state.mlModel;
  el('mlModelSelect').onchange = (e) => {
    state.mlModel = e.target.value;
    state.ml.setActiveModel(state.mlModel);
    updateMLStatus();
    updateAll();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ù…ÙˆØ°Ø¬ ML Ø¥Ù„Ù‰ ${getMLModelName(state.mlModel)}`);
  };

  el('btnP').onclick = () => pushRound('P');
  el('btnB').onclick = () => pushRound('B');
  el('btnT').onclick = () => pushRound('T');
  el('btnUndo').onclick = undoRound;
  el('btnReset').onclick = resetAll;
  
  el('btnExport').onclick = () => dataManager.exportData();
  el('btnImport').onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      if (e.target.files && e.target.files[0]) {
        dataManager.importData(e.target.files[0]);
      }
    };
    input.click();
  };
  el('btnClearData').onclick = () => dataManager.clearAllData();
  
  el('themeToggle').onclick = toggleTheme;
  
  if (!document.documentElement.hasAttribute('data-theme')) {
    document.documentElement.setAttribute('data-theme', 'dark');
  }
  
  dataManager.startAutoSave(30);
  
  updateAll();
  updateMLStatus();
  dataManager.updateDataStats();
  
  console.log('Initialization complete');
}

function toggleTheme() {
  const currentTheme = document.documentElement.getAttribute('data-theme');
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', newTheme);
  el('themeToggle').textContent = newTheme === 'dark' ? 'ğŸŒš' : 'ğŸŒ•';
  updateAccuracyChart();
}

function showToast(message, type = 'success') {
  const toast = document.createElement('div');
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'error' ? '#ef4444' : '#10b981'};
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    animation: slideIn 0.3s ease-out;
  `;
  
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.style.animation = 'slideOut 0.3s ease-in';
    setTimeout(() => {
      if (toast.parentNode) {
        document.body.removeChild(toast);
      }
    }, 300);
  }, 3000);
}

function getModeName(mode) {
  const names = { basic: 'Ø£Ø³Ø§Ø³ÙŠ', advanced: 'Ù…ØªÙ‚Ø¯Ù…', pattern: 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·', ml: 'ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©' };
  return names[mode] || mode;
}

function getWeightingName(weighting) {
  const names = { none: 'Ø¨Ø¯ÙˆÙ†', linear: 'Ø®Ø·ÙŠ', exponential: 'Ø£Ø³Ù‘ÙŠ' };
  return names[weighting] || weighting;
}

function getMLModelName(model) {
  const names = { knn: 'K-Ø§Ù„Ø¬ÙŠØ±Ø§Ù† Ø§Ù„Ø£Ù‚Ø±Ø¨', logistic: 'Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± Ø§Ù„Ù„ÙˆØ¬Ø³ØªÙŠ', ensemble: 'Ø§Ù„Ù…Ø¬Ù…Ø¹' };
  return names[model] || model;
}

// ========== Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ ==========

function frequencyAnalysis(rounds) {
  if (!rounds || rounds.length === 0) {
    return { P: 33.3, B: 33.3, T: 33.3 };
  }
  
  const counts = { P: 0, B: 0, T: 0 };
  rounds.forEach(x => { if (x in counts) counts[x]++; });
  
  const total = rounds.length;
  return {
    P: Number(((counts.P / total) * 100).toFixed(1)),
    B: Number(((counts.B / total) * 100).toFixed(1)),
    T: Number(((counts.T / total) * 100).toFixed(1))
  };
}

function patternAnalysis(rounds) {
  if (!rounds || rounds.length < 3) {
    return { P: 0, B: 0, T: 0 };
  }

  const patterns = {};
  for (let i = 2; i < rounds.length; i++) {
    const pattern = rounds.slice(i-2, i).join('');
    const next = rounds[i];
    
    if (!patterns[pattern]) {
      patterns[pattern] = { P: 0, B: 0, T: 0, total: 0 };
    }
    
    if (next in patterns[pattern]) {
      patterns[pattern][next]++;
      patterns[pattern].total++;
    }
  }

  if (rounds.length >= 2) {
    const lastPattern = rounds.slice(-2).join('');
    const patternData = patterns[lastPattern];
    
    if (patternData && patternData.total >= 1) {
      return {
        P: Number(((patternData.P / patternData.total) * 100).toFixed(1)),
        B: Number(((patternData.B / patternData.total) * 100).toFixed(1)),
        T: Number(((patternData.T / patternData.total) * 100).toFixed(1))
      };
    }
  }

  return { P: 0, B: 0, T: 0 };
}

function applyTimeWeighting(rounds, basePrediction) {
  if (state.timeWeighting === 'none' || !rounds || rounds.length < 2) {
    return basePrediction;
  }

  const n = rounds.length;
  let weightFactor = 1;
  
  if (state.timeWeighting === 'linear') {
    weightFactor = 0.8 + (0.4 * (1 / n));
  } else if (state.timeWeighting === 'exponential') {
    weightFactor = 0.7 + (0.6 * Math.pow(0.9, n));
  }

  return {
    P: Number((basePrediction.P * weightFactor).toFixed(1)),
    B: Number((basePrediction.B * weightFactor).toFixed(1)),
    T: Number((basePrediction.T * weightFactor).toFixed(1))
  };
}

function enhancedPredict() {
  const n = Math.min(state.windowSize, state.rounds.length);
  const recent = state.rounds.slice(-n);
  
  if (recent.length === 0) {
    return { 
      P: 33.3, B: 33.3, T: 33.3, 
      final: 'â€”',
      confidence: 0,
      model: 'basic',
      mlContribution: 0
    };
  }

  let basePrediction, patternBoost, finalPrediction;
  let modelUsed = state.analysisMode;
  let mlContribution = 0;

  switch(state.analysisMode) {
    case 'basic':
      basePrediction = frequencyAnalysis(recent);
      finalPrediction = basePrediction;
      break;
      
    case 'advanced':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      finalPrediction = {
        P: Number((basePrediction.P * 0.7 + patternBoost.P * 0.3).toFixed(1)),
        B: Number((basePrediction.B * 0.7 + patternBoost.B * 0.3).toFixed(1)),
        T: Number((basePrediction.T * 0.7 + patternBoost.T * 0.3).toFixed(1))
      };
      break;
      
    case 'pattern':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      finalPrediction = {
        P: Number((basePrediction.P * 0.4 + patternBoost.P * 0.6).toFixed(1)),
        B: Number((basePrediction.B * 0.4 + patternBoost.B * 0.6).toFixed(1)),
        T: Number((basePrediction.T * 0.4 + patternBoost.T * 0.6).toFixed(1))
      };
      break;
      
    case 'ml':
      basePrediction = frequencyAnalysis(recent);
      
      let mlPrediction = state.ml.predict(state.rounds, state.windowSize);
      if (!mlPrediction) {
        mlPrediction = { P: 33.3, B: 33.3, T: 33.3 };
      }
      
      const mlWeight = state.ml.getMLWeight();
      mlContribution = Number((mlWeight * 100).toFixed(1));
      
      finalPrediction = {
        P: Number((basePrediction.P * (1 - mlWeight) + mlPrediction.P * mlWeight).toFixed(1)),
        B: Number((basePrediction.B * (1 - mlWeight) + mlPrediction.B * mlWeight).toFixed(1)),
        T: Number((basePrediction.T * (1 - mlWeight) + mlPrediction.T * mlWeight).toFixed(1))
      };
      break;
  }

  finalPrediction = applyTimeWeighting(recent, finalPrediction);

  const sum = finalPrediction.P + finalPrediction.B + finalPrediction.T;
  if (sum > 0) {
    finalPrediction.P = Number(((finalPrediction.P / sum) * 100).toFixed(1));
    finalPrediction.B = Number(((finalPrediction.B / sum) * 100).toFixed(1));
    finalPrediction.T = Number(((finalPrediction.T / sum) * 100).toFixed(1));
  }

  const entries = Object.entries(finalPrediction);
  const sorted = entries.sort((a, b) => b[1] - a[1]);
  
  const confidence = Math.min(100, Math.max(0, sorted[0][1] - (sorted[1] ? sorted[1][1] : 0)));
  
  let final = sorted[0][0];
  
  if (confidence < 15) {
    final = 'â€”';
  }

  return {
    P: finalPrediction.P,
    B: finalPrediction.B,
    T: finalPrediction.T,
    final,
    confidence: Number(confidence.toFixed(1)),
    model: modelUsed,
    mlContribution: mlContribution
  };
}

function pushRound(r) {
  if (!['P', 'B', 'T'].includes(r)) return;
  
  const predBefore = enhancedPredict();
  state.lastPrediction = predBefore.final;
  
  state.ml.updateModel(state.rounds, state.windowSize, r);
  
  state.rounds.push(r);
  state.count[r]++;
  
  if (predBefore.final !== 'â€”' && ['P', 'B', 'T'].includes(predBefore.final)) {
    if (r === predBefore.final) {
      state.win[predBefore.final]++;
      state.modelPerformance[state.analysisMode] = (state.modelPerformance[state.analysisMode] || 0) + 1;
    } else {
      state.loss[predBefore.final] = (state.loss[predBefore.final] || 0) + 1;
    }
  }
  
  updateAccuracyData(r, predBefore);
  
  const newPred = enhancedPredict();
  updatePredictionDisplay(newPred);
  
  el('finalCard').classList.remove('win-effect', 'loss-effect');
  setTimeout(() => {
    if (predBefore.final === r) {
      el('finalCard').classList.add('win-effect');
    } else if (predBefore.final !== 'â€”') {
      el('finalCard').classList.add('loss-effect');
    }
  }, 10);
  
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
}

function undoRound() {
  if (state.rounds.length === 0) return;
  
  const lastRound = state.rounds.pop();
  state.count[lastRound] = Math.max(0, (state.count[lastRound] || 0) - 1);
  
  if (state.predictionsHistory.length > 0) {
    const lastPrediction = state.predictionsHistory[state.predictionsHistory.length - 1];
    if (lastPrediction && lastPrediction.prediction !== 'â€”') {
      if (lastPrediction.correct) {
        state.win[lastPrediction.prediction] = Math.max(0, (state.win[lastPrediction.prediction] || 0) - 1);
        state.modelPerformance[lastPrediction.model] = Math.max(0, (state.modelPerformance[lastPrediction.model] || 0) - 1);
      } else {
        state.loss[lastPrediction.prediction] = Math.max(0, (state.loss[lastPrediction.prediction] || 0) - 1);
      }
    }
    state.predictionsHistory.pop();
  }
  
  state.lastPrediction = null;
  
  state.ml.reset();
  if (state.rounds.length > state.windowSize) {
    for (let i = state.windowSize; i < state.rounds.length; i++) {
      const recent = state.rounds.slice(i - state.windowSize, i);
      state.ml.updateModel(recent, state.windowSize, state.rounds[i]);
    }
  }
  
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  showToast('ØªÙ… Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø¢Ø®Ø± Ø¬ÙˆÙ„Ø©');
}

function resetAll() {
  if (state.rounds.length === 0) return;
  
  if (!confirm('Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ')) return;
  
  state.rounds = [];
  state.count = { P: 0, B: 0, T: 0 };
  state.win = { P: 0, B: 0, T: 0 };
  state.loss = { P: 0, B: 0, T: 0 };
  state.lastPrediction = null;
  state.predictionsHistory = [];
  state.modelPerformance = { basic: 0, advanced: 0, pattern: 0, ml: 0 };
  state.previousPredictions = { P: 0, B: 0, T: 0 };
  
  state.ml.reset();
  
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  showToast('ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
}

function updatePredictionDisplay(pred) {
  el('predPctP').textContent = pred.P + '%';
  el('predPctB').textContent = pred.B + '%';
  el('predPctT').textContent = pred.T + '%';
  
  ['P', 'B', 'T'].forEach(type => {
    const trendEl = el('predTrend' + type);
    if (trendEl) {
      trendEl.textContent = 'â†’';
      trendEl.style.color = 'var(--muted)';
    }
  });
  
  ['predP', 'predB', 'predT'].forEach(id => {
    el(id).classList.remove('active');
  });
  
  if (pred.final !== 'â€”') {
    const finalEl = el('pred' + pred.final);
    if (finalEl) finalEl.classList.add('active');
  }
  
  let finalText = 'â€”';
  if (pred.final === 'P') finalText = 'Ù„Ø§Ø¹Ø¨';
  else if (pred.final === 'B') finalText = 'Ù…ØµØ±ÙÙŠ';
  else if (pred.final === 'T') finalText = 'ØªØ¹Ø§Ø¯Ù„';
  
  el('finalCard').textContent = finalText;
  
  el('mlContribution').textContent = pred.mlContribution > 0 ? 
    `ğŸ“Š Ù…Ø³Ø§Ù‡Ù…Ø© ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©: ${pred.mlContribution}%` : '';
  
  updateConfidenceMeter(pred.confidence);
  updateModelInfo(pred);
}

function updateConfidenceMeter(confidence) {
  const fill = el('confidenceFill');
  const label = el('confidenceLabel');
  
  if (!fill || !label) return;
  
  fill.style.width = confidence + '%';
  
  if (confidence >= 30) {
    fill.className = 'confidence-fill high-confidence';
    label.textContent = 'Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©';
    label.style.color = '#38b000';
  } else if (confidence >= 15) {
    fill.className = 'confidence-fill medium-confidence';
    label.textContent = 'Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø©';
    label.style.color = '#d4af37';
  } else {
    fill.className = 'confidence-fill';
    label.textContent = 'Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©';
    label.style.color = '#ff006e';
  }
}

function updateModelInfo(pred) {
  const modelEl = el('predModel');
  const modelInfoEl = el('modelInfo');
  const reasonEl = el('predictionReason');
  
  if (!modelEl || !modelInfoEl || !reasonEl) return;
  
  let modelName, modelClass, reason;
  
  switch(pred.model) {
    case 'basic':
      modelName = 'Ø£Ø³Ø§Ø³ÙŠ';
      modelClass = 'badge-basic';
      reason = 'ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ';
      break;
    case 'advanced':
      modelName = 'Ù…ØªÙ‚Ø¯Ù…';
      modelClass = 'badge-advanced';
      reason = 'ÙŠØ¬Ù…Ø¹ Ø¨ÙŠÙ† ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø·';
      break;
    case 'pattern':
      modelName = 'Ø§Ù„Ø£Ù†Ù…Ø§Ø·';
      modelClass = 'badge-pattern';
      reason = 'ÙŠØ±ÙƒØ² Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ³Ù„Ø³Ù„Ø§Øª ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø·';
      break;
    case 'ml':
      modelName = 'ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©';
      modelClass = 'badge-ml';
      reason = 'ÙŠØ³ØªØ®Ø¯Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ML Ù…Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ';
      break;
    default:
      modelName = 'Ø£Ø³Ø§Ø³ÙŠ';
      modelClass = 'badge-basic';
      reason = 'ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ';
  }
  
  modelEl.textContent = modelName;
  modelEl.className = 'model-badge ' + modelClass;
  
  const efficiency = calculateModelEfficiency();
  modelInfoEl.textContent = `Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: ${modelName} - Ø§Ù„ÙƒÙØ§Ø¡Ø©: ${efficiency}%`;
  
  if (pred.final === 'â€”') {
    reasonEl.textContent = 'Ø¹Ø¯Ù… ÙƒÙØ§ÙŠØ© Ø§Ù„Ø«Ù‚Ø© Ù„Ù„ØªÙ†Ø¨Ø¤';
  } else {
    reasonEl.textContent = reason + ` - Ø§Ù„Ø«Ù‚Ø©: ${pred.confidence}%`;
  }
}

function calculateModelEfficiency() {
  const total = Object.values(state.modelPerformance).reduce((a, b) => a + b, 0);
  const current = state.modelPerformance[state.analysisMode] || 0;
  return total > 0 ? Math.round((current / total) * 100) : 0;
}

function updateMLStatus() {
  const trainingCount = state.ml.getTrainingDataCount();
  const mlWeight = state.ml.getMLWeight() * 100;
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  
  el('mlTrainingCount').textContent = trainingCount;
  el('mlWeight').textContent = mlWeight.toFixed(0) + '%';
  el('mlAccuracy').textContent = mlAccuracy + '%';
  
  const statusEl = el('mlStatus');
  if (!statusEl) return;
  
  if (trainingCount < 5) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-not-trained"></span> ÙŠØ­ØªØ§Ø¬ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª';
    statusEl.style.color = '#ff006e';
  } else if (trainingCount < 15) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> ÙŠØªØ¹Ù„Ù…...';
    statusEl.style.color = '#d4af37';
  } else {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> Ø¬Ø§Ù‡Ø² Ù„Ù„ØªÙ†Ø¨Ø¤';
    statusEl.style.color = '#38b000';
  }
  
  el('mlOverallAccuracy').textContent = mlAccuracy + '%';
}

function updateAll() {
  renderStats();
  renderBigRoad();
  updatePredictionCounts();
  updateAccuracyStats();
  updateAccuracyChart();
  updatePatternInfo();
  updateMLStats();
  dataManager.updateDataStats();
}

function renderStats() {
  el('pTotal').textContent = state.count.P || 0;
  el('bTotal').textContent = state.count.B || 0;
  el('tTotal').textContent = state.count.T || 0;
  
  el('pWin').textContent = state.win.P || 0;
  el('bWin').textContent = state.win.B || 0;
  el('tWin').textContent = state.win.T || 0;
  
  el('pLoss').textContent = state.loss.P || 0;
  el('bLoss').textContent = state.loss.B || 0;
  el('tLoss').textContent = state.loss.T || 0;
  
  el('pPct').textContent = calculatePercentage(state.win.P, state.loss.P);
  el('bPct').textContent = calculatePercentage(state.win.B, state.loss.B);
  el('tPct').textContent = calculatePercentage(state.win.T, state.loss.T);
  
  el('pAccuracy').textContent = calculateAccuracy('P');
  el('bAccuracy').textContent = calculateAccuracy('B');
  el('tAccuracy').textContent = calculateAccuracy('T');
  
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  el('pMLAccuracy').textContent = (mlAccuracy * 0.9).toFixed(1) + '%';
  el('bMLAccuracy').textContent = (mlAccuracy * 0.95).toFixed(1) + '%';
  el('tMLAccuracy').textContent = (mlAccuracy * 0.7).toFixed(1) + '%';
}

function calculatePercentage(win, loss) {
  const total = (win || 0) + (loss || 0);
  return total > 0 ? ((win / total) * 100).toFixed(1) + '%' : '0%';
}

function calculateAccuracy(type) {
  const predictionsForType = state.predictionsHistory.filter(p => p.prediction === type);
  const correctForType = predictionsForType.filter(p => p.correct).length;
  return predictionsForType.length > 0 ? ((correctForType / predictionsForType.length) * 100).toFixed(1) + '%' : '0%';
}

function renderBigRoad() {
  const canvas = el('bigRoad');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  if (state.rounds.length === 0) return;
  
  const size = 35;
  let x = 0, y = 0;
  const maxCols = Math.floor(canvas.width / size);
  
  for (let i = 0; i < state.rounds.length; i++) {
    const r = state.rounds[i];
    
    ctx.fillStyle = r === 'P' ? '#3a86ff' : r === 'B' ? '#ff006e' : '#38b000';
    ctx.fillRect(x * size, y * size, size - 2, size - 2);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px Inter';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText((i+1).toString(), x * size + size/2, y * size + size/2);
    
    y++;
    if (y * size >= canvas.height) {
      y = 0;
      x++;
      if (x >= maxCols) break;
    }
  }
}

function updatePredictionCounts() {
  const pred = enhancedPredict();
  updatePredictionDisplay(pred);
}

function updatePatternInfo() {
  const infoEl = el('patternInfo');
  if (!infoEl) return;
  
  if (state.rounds.length < 3) {
    infoEl.textContent = 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…ÙƒØªØ´ÙØ© Ø¨Ø¹Ø¯';
    return;
  }
  
  const recent = state.rounds.slice(-5);
  const pCount = recent.filter(r => r === 'P').length;
  const bCount = recent.filter(r => r === 'B').length;
  const tCount = recent.filter(r => r === 'T').length;
  
  let info = `Ø¢Ø®Ø± 5 Ø¬ÙˆÙ„Ø§Øª: ğŸ”µ${pCount} ğŸ”´${bCount} ğŸŸ¢${tCount}`;
  
  if (state.rounds.length >= 3) {
    const lastThree = state.rounds.slice(-3).join('');
    info += ` | Ø¢Ø®Ø± 3: ${lastThree}`;
  }
  
  infoEl.textContent = info;
}

function updateAccuracyData(actualResult, pred) {
  if (pred.final !== 'â€”' && ['P', 'B', 'T'].includes(pred.final)) {
    state.predictionsHistory.push({
      prediction: pred.final,
      actual: actualResult,
      correct: pred.final === actualResult,
      model: pred.model,
      confidence: pred.confidence
    });
    
    if (state.predictionsHistory.length > 100) {
      state.predictionsHistory = state.predictionsHistory.slice(-100);
    }
  }
}

function updateAccuracyStats() {
  if (state.predictionsHistory.length === 0) {
    el('currentAccuracy').textContent = '0%';
    el('bestAccuracy').textContent = '0%';
    el('averageAccuracy').textContent = '0%';
    return;
  }
  
  const correct = state.predictionsHistory.filter(p => p.correct).length;
  const total = state.predictionsHistory.length;
  const currentAccuracy = total > 0 ? (correct / total) * 100 : 0;
  
  let bestAccuracy = 0;
  for (let i = 1; i <= state.predictionsHistory.length; i++) {
    const slice = state.predictionsHistory.slice(0, i);
    const sliceCorrect = slice.filter(p => p.correct).length;
    const sliceAccuracy = (sliceCorrect / i) * 100;
    if (sliceAccuracy > bestAccuracy) bestAccuracy = sliceAccuracy;
  }
  
  el('currentAccuracy').textContent = currentAccuracy.toFixed(1) + '%';
  el('bestAccuracy').textContent = bestAccuracy.toFixed(1) + '%';
  el('averageAccuracy').textContent = (state.predictionsHistory.reduce((acc, p) => acc + (p.correct ? 1 : 0), 0) / total * 100).toFixed(1) + '%';
}

function updateAccuracyChart() {
  const svg = el('accuracyChart');
  const tooltip = el('accuracyTooltip');
  if (!svg || !tooltip) return;
  
  svg.innerHTML = '';
  
  if (state.predictionsHistory.length < 2) return;
  
  const width = Math.max(svg.clientWidth || 600, 100);
  const height = Math.max(svg.clientHeight || 80, 50);
  const padding = 20;
  
  const accuracies = [];
  let correctCount = 0;
  for (let i = 0; i < state.predictionsHistory.length; i++) {
    if (state.predictionsHistory[i].correct) correctCount++;
    accuracies.push((correctCount / (i + 1)) * 100);
  }
  
  for (let i = 0; i <= 100; i += 20) {
    const y = height - padding - (i / 100) * (height - 2 * padding);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('class', 'accuracy-grid');
    line.setAttribute('x1', padding);
    line.setAttribute('y1', y);
    line.setAttribute('x2', width - padding);
    line.setAttribute('y2', y);
    svg.appendChild(line);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', padding - 5);
    text.setAttribute('y', y + 4);
    text.setAttribute('text-anchor', 'end');
    text.setAttribute('fill', 'var(--muted)');
    text.setAttribute('font-size', '10px');
    text.textContent = i + '%';
    svg.appendChild(text);
  }
  
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  let pathData = '';
  
  accuracies.forEach((accuracy, index) => {
    const x = padding + (index / (accuracies.length - 1)) * (width - 2 * padding);
    const y = height - padding - (accuracy / 100) * (height - 2 * padding);
    
    if (index === 0) {
      pathData = `M ${x} ${y}`;
    } else {
      pathData += ` L ${x} ${y}`;
    }
    
    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    point.setAttribute('class', 'accuracy-point');
    point.setAttribute('cx', x);
    point.setAttribute('cy', y);
    point.setAttribute('r', 3);
    
    point.addEventListener('mouseover', (e) => {
      const rect = svg.getBoundingClientRect();
      tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
      tooltip.style.top = (e.clientY - rect.top - 30) + 'px';
      tooltip.textContent = `Ø§Ù„Ø¬ÙˆÙ„Ø© ${index + 1}: ${accuracy.toFixed(1)}%`;
      tooltip.style.opacity = '1';
    });
    
    point.addEventListener('mouseout', () => {
      tooltip.style.opacity = '0';
    });
    
    svg.appendChild(point);
  });
  
  path.setAttribute('d', pathData);
  path.setAttribute('class', 'accuracy-line');
  svg.appendChild(path);
}

const style = document.createElement('style');
style.textContent = `
@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}
@keyframes slideOut {
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(100%); opacity: 0; }
}
`;
document.head.appendChild(style);

window.addEventListener('DOMContentLoaded', init);
})();
</script>
</body>
</html>
